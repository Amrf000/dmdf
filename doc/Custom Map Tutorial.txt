Custom Map Tutorial
by Barad√©

Step 1: Importing and defining code
First you should define all ASL required boolean constants in your custom map script:
globals
	constant boolean A_RTC = false
	constant boolean A_JAPI = false
	constant boolean A_SYSTEMS = true
	constant boolean A_OBJECTS = true
	constant boolean A_DEBUG_HANDLES = false
	constant boolean A_DEBUG_NATIVES = false
	constant boolean A_NET = false
	constant boolean A_FPS_MOVEMENT = false
endglobals

After that define the following constants in your custom map script:
DMDF_TRADE - enables trade system via dialog
DMDF_INVENTORY - enables advanced graphical inventory system
DMDF_CHARACTER_MEMORY_ADMINISTRATION - enables saving and loading characters from disk
DMDF_INFO_LOG - enables talk log system (GUI)
DMDF_NPC_ROUTINES - enables NPC routines
DMDF_CHARACTER_STATS - enables character stats system (GUI)
DMDF_VIOLENCE - enables violence system (blood effects/sounds)

After that you'll have to import the ASL and "Die Macht des Feuers" code by using the following
statements in your custom map script:
//! import "Import Asl.j"
//! import "Import Dmdf.j"

Note that your JassHelper lookup folders should be set correctly to the ASL's and DMdF's "src" folders.
Your custom map code should be imported like this:
//! import "CustomMapName/Import.j"

Here's an example custom map script of map "Talras":
globals
	constant boolean A_RTC = false
	constant boolean A_JAPI = false
	constant boolean A_SYSTEMS = true
	constant boolean A_OBJECTS = true
	constant boolean A_DEBUG_HANDLES = false
	constant boolean A_DEBUG_NATIVES = false
	constant boolean A_NET = false
	constant boolean A_FPS_MOVEMENT = false
	constant boolean DMDF_TRADE = true
	constant boolean DMDF_INVENTORY = true
	constant boolean DMDF_CHARACTER_MEMORY_ADMINISTRATION = true
	constant boolean DMDF_INFO_LOG = true
	constant boolean DMDF_NPC_ROUTINES = true
	constant boolean DMDF_CHARACTER_STATS = true
	constant boolean DMDF_VIOLENCE = true
endglobals

//! import "Import Asl.j"
//! import "Import Dmdf.j"
//! import "Talras/Import.j"

It's highly recommended by me that you divide your map code into several files which are placed
in various directories.
Your map code folder should look like this:
Spells - directory for map-specific spell structs
Map - directory for default map structs
Videos - directory for map video structs
Quests - directory for map quest structs
Talks - directory for map talk structs
Import.j - file for map code library and import statements

...


Step 2: Creating map terrain
First of all you have to know that "Die Macht des Feuers" uses its own tileset ids.
They are specified in file "TerrainArt/Terrain.slk" of the MPQ archive and replace
Warcraft TFT's ones.
At the moment there are only tileset graphics for grassland terrains (created by Born2Modificate).
The graphics textures are stored in directory "TerrainArt/Ambient/Grassland".
Look into file "TerrainArt/README" to get a list of all available custom tileset ids.
Of course you're also free to use the default Warcraft 3 TFT ones but I wouldn't recommend this
since many of them could also be replaced in later versions of "Die Macht des Feuers".

To avoid the editor's terrain graphics limit you'll have to use the grimoire extensions tool
"Tilesetter" which can either be used by using a single preprocessor statement line or by its
GUI in the JNGP.

Additionally I recommend you to define


Step 4: Creating rects
There is a list of color definitions for those various rect types which are used in maps:
cheat rects - purple
quest rects - white
layer rects - orange
main window rects - black
shrine discover rects - yellow
shrine revival rects - red
spawn point rects - grey
video rects - green
waypoint rects - grey blue
weather rects - dark green
music rects - pink
marker rects - magenta
default map rects - lite blue

Besides there are some naming conventions:
cheat rects - "cheat <cheat name>"
quest rects - "quest <quest name> [quest item <quest item number> | <user-specific description>]"
layer rects - "layer <layer name> [entry <entry number> | exit <exit number>]"
main window rects - "main window <main window name>"
shrine discover rects - "shrine <shrine number|shrine identifier> discover"
shrine revival rects - "shrine <shrine number|shrine identifier> revival"
spawn point rects - "spawn point <spawn point identifier|<spawn point creature name> <spawn point number of spawn points with same creature type>>"
video rects - "video <video name> <rect identifier>"
waypoint rects - "waypoint <npc name> <rect number|rect identifier>"
weather rects - "weather <location name>"
music rects - "music <location name>"
marker rects - "marker <marker name>"
default map rects - "<rect name>"

Default map rects are:
game GUI locations
class selection location
character start locations
playable area
various other rects for map-specific content (e. g. AOS or arena rects/spawn points)

Step 5: Required map rects
There are several rects which are necessarily required by code:
"class selection" - class selection rect where classes units are being created.
"worker" - worker rect where worker is being created (for getting enabled shrine).
"main window credits" - main window rect for credits GUI
"main window info log" - main window rect for info log GUI (note that this shouldn't be required if DMDF_INFO_LOG is false)
"main window inventory" - main window rect for inventory GUI (note that this shouldn't be required if DMDF_INVENTORY is false)

Step 6: Creating cameras
Cameras should always have the name of their video if they correspond to any.
The following list shows which cameras are required in all maps:
"class selection" - camera for class selection which is shown at the beginning of game
"talk" - camera for talks which isn't used anymore (since we have a new third person camera system)
"main window" - camera for main window view (usually used for all main windows)

We recommend you to test your created camera ways in the World Editor's GUI trigger editor. Probably
the easiest way to create cinematics is to call camera apply actions in a newly created trigger and
to press the preview button. Do not forget to call the wait actions.

Usually cameras are identified in a standardised way (as map rects):
video cameras - "video <video name> <camera identifier>"

Creating shrines

Creating struct MapData

public static constant string mapMusic - contains a list of default map music files. Will be played automatically after class selection when game starts.

Placing NPCs
NPCs are primarily usual units which can have custom routines and talks, can trade items, give quests to characters,
play in cinematics or even become henchmen of characters.
Thus first thing you have to do is to place the NPC's unit.
Usually NPC units belong to player "Neutral Passive" and are invulnerable.
It's more convenient to create global variables which store your NPC units. We recommend you not to create your
NPC's in code. Just place them on your map, call any trigger action on them that World Editor generates
a global variable which stores your unit.
Those global variables are identified as "gg_unit_<id>". After you've done this you can create your custom
variable and store the unit because it's difficult to know which id belongs to which unit.

Creating routines

Creating talks

Creating secundary missions

Creating primary missions

Creating videos

Creating spawn points

Releasing map

Steps:
* Check equality of object data to other maps.
* Generate map shadows when saving map.
* Generate string translation files for selected languages by using jasstrans.
* Generate map file name by using new version.

Releasing DMdF version

Steps:
* Convert all textures/icons into correct format (which means converting them into BLP format and adding MIP maps if necessary -> see below).
* Generate missing button icons (BTN etc.)
* Generate maxmimum MIP maps for non-interface textures (units, effects etc.).
* Check all model texture paths
* Generate and compress new MPQ archive with best algorithms
* Generate exe file by adding newly created MPQ archive
