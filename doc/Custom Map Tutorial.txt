Custom Map Tutorial
by Barad√©

This tutorial covers how to create a custom map for the modification "The Power of Fire".

Step 1: Importing and defining code
First you should define all ASL required boolean constants in your custom map script:
globals
	constant boolean A_SYSTEMS = true
	constant boolean A_DEBUG_HANDLES = false
	constant boolean A_DEBUG_NATIVES = false
	constant real A_MAX_COLLISION_SIZE = 300
	constant integer A_MAX_COLLISION_SIZE_ITERATIONS = 10
	constant integer A_SPELL_RESISTANCE_CREEP_LEVEL = 6
endglobals

After that define the following constants in your custom map script:
DMDF_INFO_LOG - enables talk log system (GUI)
DMDF_NPC_ROUTINES - enables NPC routines
DMDF_VIOLENCE - enables violence system (blood effects/sounds)
DMDF_CREDITS - enables credits (GUI)

After that you'll have to import the ASL and "Die Macht des Feuers" code by using the following
statements in your custom map script:
//! import "Import Asl.j"
//! import "Import Dmdf.j"

Note that your JassHelper lookup folders should be set correctly to the ASL's and DMdF's "src" folders.
Your custom map code should be imported like this:
//! import "CustomMapName/Import.j"

Here's an example custom map script of map "Talras":
globals
	constant boolean A_SYSTEMS = true
	constant boolean A_DEBUG_HANDLES = false
	constant boolean A_DEBUG_NATIVES = false
	constant real A_MAX_COLLISION_SIZE = 300
	constant integer A_MAX_COLLISION_SIZE_ITERATIONS = 10
	constant integer A_SPELL_RESISTANCE_CREEP_LEVEL = 6
	constant boolean DMDF_INFO_LOG = true
	constant boolean DMDF_NPC_ROUTINES = true
	constant boolean DMDF_VIOLENCE = true
	constant boolean DMDF_CREDITS = true
endglobals

//! import "Import Asl.j"
//! import "Import Dmdf.j"
//! import "Talras/Import.j"

It's highly recommended by me that you divide your map code into several files which are placed
in various directories.
Your map code folder should look like this:
Spells - directory for map-specific spell structs
Map - directory for default map structs
Videos - directory for map video structs
Quests - directory for map quest structs
Talks - directory for map talk structs
Import.j - file for map code library and import statements

...

You have to provide the static struct MapData which defines several constants and methods required by the modification:

struct MapData extends MapDataInterface
	/// The map name is used for zones for example to detect the map file name.
	public static constant string mapName = "TL"
	/// This list of music files is set as map music during the map initialization.
	public static constant string mapMusic = "Sound\\Music\\mp3Music\\Pippin the Hunchback.mp3;Sound\\Music\\mp3Music\\Minstrel Guild.mp3"// //"Music\\Ingame.mp3;Music\\Talras.mp3"
	/// The maximum number of human players who control a character.
	public static constant integer maxPlayers = 6
	/// The player who owns fellows whose control is shared by all users.
	public static constant player alliedPlayer = Player(6)
	/// The player for actors during video sequences. This prevents returning the units to their creep spots automatically.
	public static constant player neutralPassivePlayer = Player(7)
	/// This player is only required by Talras since there is an arena with opponents.
	public static constant player arenaPlayer = Player(8)
	public static constant real morning = 5.0
	public static constant real midday = 12.0
	public static constant real afternoon = 16.0
	public static constant real evening = 18.0
	/// The fixed time in seconds which it takes until a character is revived automatically after his death.
	public static constant real revivalTime = 35.0
	public static constant real revivalLifePercentage = 100.0
	public static constant real revivalManaPercentage = 100.0
	public static constant integer startLevel = 0
	public static constant integer startSkillPoints = 5 /// Includes the skill point for the default spell.
	public static constant integer levelSpellPoints = 2
	public static constant integer maxLevel = 10000
	public static constant integer workerUnitTypeId = 'h00E'
	/// If this value is true there will always be a class selection in the beginning if the map is started for the first time. Otherwise characters will be loaded from the gamecache in campaign mode if available.
	public static constant boolean isSeparateChapter = true
	public static sound cowSound = null

	private static method create takes nothing returns thistype
		return 0
	endmethod

	private method onDestroy takes nothing returns nothing
	endmethod

	/// Required by \ref Game.
	public static method init takes nothing returns nothing
	endmethod

	/**
	 * Creates the starting items for the inventory of \p whichUnit depending on \p class .
	 * Required by \ref ClassSelection.
	 */
	public static method createClassSelectionItems takes AClass class, unit whichUnit returns nothing
	endmethod

	/// Required by \ref Game.
	public static method initMapSpells takes ACharacter character returns nothing
		call initMapCharacterSpells.evaluate(character)
	endmethod

	/// Required by \ref Game.
	public static method onStart takes nothing returns nothing
		call SuspendTimeOfDay(true)
		call SetTimeOfDay(0.0)
	endmethod

	/// Required by \ref ClassSelection.
	public static method onSelectClass takes Character character, AClass class, boolean last returns nothing
	endmethod

	/// Required by \ref ClassSelection.
	public static method onRepick takes Character character returns nothing
	endmethod

	/// Required by \ref Game.
	public static method start takes nothing returns nothing
	endmethod

	/// Required by \ref Classes.
	public static method startX takes integer index returns real
		return 0.0
	endmethod

	/// Required by \ref Classes.
	public static method startY takes integer index returns real
		return 0.0
	endmethod

	/// Required by \ref Classes.
	public static method startFacing takes integer index returns real
		return 0.0
	endmethod

	/// Required by \ref MapChanger.
	public static method restoreStartX takes integer index, string zone returns real
		return GetRectCenterX(gg_rct_start_holzbruck)
	endmethod

	/// Required by \ref MapChanger.
	public static method restoreStartY takes integer index, string zone returns real
		return GetRectCenterY(gg_rct_start_holzbruck)
	endmethod

	/// Required by \ref MapChanger.
	public static method restoreStartFacing takes integer index, string zone returns real
		return 270.0
	endmethod

	/// Required by \ref MapChanger.
	public static method onRestoreCharacters takes string zone returns nothing
	endmethod

	/**
	 * \return Returns true if characters gain experience from killing units of player \p whichPlayer. Otherwise it returns false.
	 * Required by \ref Game.
	 */
	public static method playerGivesXP takes player whichPlayer returns boolean
		return whichPlayer == Player(PLAYER_NEUTRAL_AGGRESSIVE)
	endmethod

	/**
	 * Required by \ref Game. Called by .evaluate()
	 */
	public static method initVideoSettings takes nothing returns nothing
	endmethod

	/**
	 * Required by \ref Game. Called by .evaluate()
	 */
	public static method resetVideoSettings takes nothing returns nothing
	endmethod

	/// Required by \ref Buildings. Called by .evaluate()
	public static method goldmine takes nothing returns unit
		return null
	endmethod

	/// Required by teleport spells.
	public static method excludeUnitTypeFromTeleport takes integer unitTypeId returns boolean
		return false
	endmethod
endstruct

Step 2: Creating map terrain
First of all you have to know that "Die Macht des Feuers" uses its own tileset ids.
They are specified in file "TerrainArt/Terrain.slk" of the MPQ archive and replace
Warcraft TFT's ones.
At the moment there are only tileset graphics for grassland terrains (created by Born2Modificate).
The graphics textures are stored in directory "TerrainArt/Ambient/Grassland".
Look into file "TerrainArt/README" to get a list of all available custom tileset ids.
Of course you're also free to use the default Warcraft 3 TFT ones but I wouldn't recommend this
since many of them could also be replaced in later versions of "Die Macht des Feuers".

To avoid the editor's terrain graphics limit you'll have to use the grimoire extensions tool
"Tilesetter" which can either be used by using a single preprocessor statement line or by its
GUI in the JNGP.

Additionally I recommend you to define


Step 4: Creating rects
There is a list of color definitions for those various rect types which are used in maps:
cheat rects - purple
quest rects - white
layer rects - orange
main window rects - black
shrine discover rects - yellow
shrine revival rects - red
spawn point rects - grey
video rects - green
waypoint rects - grey blue
weather rects - dark green
music rects - pink
marker rects - magenta
default map rects - lite blue

Besides there are some naming conventions:
cheat rects - "cheat <cheat name>"
quest rects - "quest <quest name> [quest item <quest item number> | <user-specific description>]"
layer rects - "layer <layer name> [entry <entry number> | exit <exit number>]"
main window rects - "main window <main window name>"
shrine discover rects - "shrine <shrine number|shrine identifier> discover"
shrine revival rects - "shrine <shrine number|shrine identifier> revival"
spawn point rects - "spawn point <spawn point identifier|<spawn point creature name> <spawn point number of spawn points with same creature type>>"
video rects - "video <video name> <rect identifier>"
waypoint rects - "waypoint <npc name> <rect number|rect identifier>"
weather rects - "weather <location name>"
music rects - "music <location name>"
marker rects - "marker <marker name>"
default map rects - "<rect name>"

Default map rects are:
game GUI locations
class selection location
character start locations
playable area
various other rects for map-specific content (e. g. AOS or arena rects/spawn points)

Step 5: Required map rects
There are several rects which are necessarily required by code:
"class selection" - class selection rect where classes units are being created.
"worker" - worker rect where worker is being created (for getting enabled shrine).
"main window credits" - main window rect for credits GUI
"main window info log" - main window rect for info log GUI (note that this shouldn't be required if DMDF_INFO_LOG is false)
"main window inventory" - main window rect for inventory GUI (note that this shouldn't be required if DMDF_INVENTORY is false)

Step 6: Creating cameras
Cameras should always have the name of their video if they correspond to any.
The following list shows which cameras are required in all maps:
"class selection" - camera for class selection which is shown at the beginning of game
"talk" - camera for talks which isn't used anymore (since we have a new third person camera system)
"main window" - camera for main window view (usually used for all main windows)

We recommend you to test your created camera ways in the World Editor's GUI trigger editor. Probably
the easiest way to create cinematics is to call camera apply actions in a newly created trigger and
to press the preview button. Do not forget to call the wait actions.

Usually cameras are identified in a standardised way (as map rects):
video cameras - "video <video name> <camera identifier>"

Creating shrines

Creating struct MapData

public static constant string mapMusic - contains a list of default map music files. Will be played automatically after class selection when game starts.

Placing NPCs
NPCs are primarily usual units which can have custom routines and talks, can trade items, give quests to characters,
play in cinematics or even become henchmen of characters.
Thus first thing you have to do is to place the NPC's unit.
Usually NPC units belong to player "Neutral Passive" and are invulnerable.
It's more convenient to create global variables which store your NPC units. We recommend you not to create your
NPC's in code. Just place them on your map, call any trigger action on them that World Editor generates
a global variable which stores your unit.
Those global variables are identified as "gg_unit_<id>". After you've done this you can create your custom
variable and store the unit because it's difficult to know which id belongs to which unit.

Creating routines

Creating talks

Creating secundary missions

Creating primary missions

Creating videos

Creating spawn points

Releasing map

Steps:
* Export object data from map Talras and import it into this map. Talras is the map where object data changes should be made!
* Check equality of object data to other maps.
* Generate map shadows when saving map.
* Generate string translation files for selected languages by using the function tre() and by extracting the war3map.wts file merging it with the current German one and with the English one and translating remaining untranslated German strings.
* Generate map file name by using new version.

Releasing DMdF version

Steps:
* Convert all textures/icons into correct format (which means converting them into BLP format and adding MIP maps if necessary -> see below).
* Generate missing button icons (BTN etc.)
* Generate maxmimum MIP maps for non-interface textures (units, effects etc.).
* Check all model texture paths
* Generate and compress new MPQ archive with best algorithms
* Generate exe file by adding newly created MPQ archive
* Make sure you saved all maps without Debug mode and the latest object data
* Run script "Scripts/makereleasemaps.bat" which creates all optimized versions for the German release
* Import the file "war3map.wts" into the map Talras and save it optimized as English release.
* Copy the campaigns (English and German) and replace the maps
* Run the installer script "installer.nsi" which generates the installation setup

Creating the minimap for a map which uses custom camera bounds:
- export Minimap in WE (File -> Export Minimap, not only playable area but without icons etc.)
- open Minimap file in Gimp, select the actual Minimap area and fit the image to that size
- you can also export the Minimap with rects and use that image as background layer to align the selection.
- , scale background to 256x256, align the layer with the minimap to the exact center
- create another layer in background with 256x256 and fill it with black
- import the tga file in WE and renamde the path to "war3mapMap.tga"
- since the neutral building icons position might not find in the preview you can also import the file and use the path "war3mapPreview.tga"
- in this case you could export the Minimap WITH neutral buildings

For using the minimap as preview minimap without neutral building markers which will have wrong positions the file must be converted to "war3mapPreview.tga"
with RLE compression, format TRUE COLOR, 0 bits Alpha channel (remove Alpha channel), and orientation bottom left.
You can use BLPLab for this and just select "Remove Alpha channel" and the compression check boxes.

Optimize map files:
- Use the ultimate map SLK optimizer to optimize the object data and reduce the loading time but again to not optimize the war3map.wts file. Don't clean the Standard Objects for safety.
- Alternatively use Widgetizer.
- Use war3mapoptimizer of Vexorian but do not optimize war3map.wts files to still provide multiple languages.
- Now create an English and a German version of the map with the same name and the same data/direcotry but replace the war3map.wts file for the English version.
